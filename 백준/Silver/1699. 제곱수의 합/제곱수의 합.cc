#include <bits/stdc++.h>
using namespace std;

vector<int> dp;
/*
    dp[n]: 자연수 n을 제곱수의 합으로 표현할 때,
    사용되는 제곱수의 최소 개수

    자명한 사실)
    제곱수일 경우(1, 4, 9, 16..): 자기 자신이 제곱수이므로 1

    유추 가능한 사실)
    n을 넘지 않는 제곱수를 채택하고(1개)
    **n-제곱수** 의 최소 개수를 더하면 됨.

    따라서 dp 점화식
    dp[n]=1 ; n=제곱수
    dp[n]=min(dp[n], dp[n 넘지 않는 제곱수]+dp[n-제곱수])
    이걸 모든 제곱수에 대해 고고링함
    
    왜나면 처음에는 n 넘지 않는 수 중 가장 큰 제곱수로 했는데,
    18일 경우 반례 발생
    16+2->16+1+1 로 3개지만,
    9+9->2개로 끝날 수 있음

    따라서 각 제곱수에 따라 최소값을 비교하면서 최적의 해를 넣는다.

    이걸 
    100,000*100 = 100,000,000이니까 1초 안에 가능할둣?
    (100,000는 100*100)

*/

int dpFunc(int n){
    dp[0]=0;
    dp[1]=1;

    for (int i = 2; i <= n; i++) {
        dp[i] = i; // 최악의 경우 (모두 1^2로만 구성)
        for (int j = 1; j * j <= i; j++) { // 모든 제곱수를 동시에 고려
            dp[i] = min(dp[i], dp[i - j * j] + 1);
        }
    }


    /*
    //출력
    for(auto it:dp){
        cout<<it<<" ";
    }
    cout<<"\n";
    */

    return dp[n];
}

int main() {
    int n;
    cin>>n;
    
    dp.assign(n+1, 0);

    cout<<dpFunc(n);
    
    return 0;
}